$o_commentary1 =
  'classメソッドはレシーバーのクラスを返します。
今回はClassクラスのインスタンスに対してclassメソッドを呼んでいます。
よって「Class」と表示されます。'

$o_commentary2 =
  'classメソッドはレシーバーのクラスを返すメソッドです。
今回はC1というクラスのインスタンスに対してclassメソッドを呼んでいますので「C1」と表示されます。'

$o_commentary3 =
  'initializeメソッドは定義されたクラスの初期化メソッドです。
そして今回ではC1クラスを継承しているC2クラスのインスタンスに対してm_1メソッドを呼んでいます。
サブクラス(ここではC2)でinitializeメソッドを定義しなかった場合、initializeメソッドも継承されます。
よってC2インスタンスが生成された際にも変数@fooには文字列"foo"が代入されています。
よって"foo"と表示されます。
'

$o_commentary4 =
'今回の問題ではC1クラスを継承したC2クラスのインスタンスをレシーバとしてプライベートメソッドであるm_2を呼んでいるので例外が発生しています。
レシーバを指定して呼び出す事が出来ないのはprivateメソッドの特徴の一つです。
またC2.private_instance_methodsとするとm_2メソッドがprivateメソッドであることが分かります。'

$o_commentary5 =
  '今回の問題ではC1クラスを継承したC2インスタンでm_1メソッドを呼び出しています。
m_1メソッドではC1インスタンスに対してprotectedメソッドであるm_2メソッドを呼び出しています。
m_2メソッドはインスタンス変数である@fooと@barが+メソッドで連結されていますがここに代入されているのはC2インスタンスを作成した際にinitializeメソッドで初期化された際に"foo"と"bar"が代入されています。
よってここでは+メソッドによって文字列連結されている為、"foobar"と表示されます。'

$o_commentary6 =
  'この問題ではC1クラスを継承したC1クラスのインスタンスをレシーバとしてm_2メソッドを呼び出してrいます。
クラス内で「private: メソッド名」とするとそのメソッドはprivateメソッドになります。
レシーバを指定して呼び出す事が出来ないのはprivateメソッドの特徴の一つです。
よってここでは例外が発生します。'

$o_commentary7 =
  'C1クラスを継承したC2クラスにインスタンスを生成して変数c2に代入しています。
classメソッドはレシーバーのクラスを返します。
よってここでは「C2」と表示されます。'

$o_commentary8 =
  'C1クラスを継承したC2クラスで生成したインスタンスに対してsuperclassメソッドを呼んでいます。
インスタンスに対してsuperclassは定義されていない為、ここでは例外が発生します。
「C2.superclass」としてC2に対して呼ぶとsuperclass(親クラス)である「C1」と表示されます。'

$o_commentary9 =
  'ここではC1クラスを継承したC2クラスに対してancestorsメソッドを呼んでいます。
ancestorsメソッドはクラス、モジュールのスーパークラスとインクルードしているモジュールを優先順位順に配列に格納して返します。
さらにlastメソッドで配列の最後の要素を取り出している為、「BasicObject」と表示されます。'

$o_commentary10 =
'ancestorsメソッドはクラス、モジュールのスーパークラスとインクルードしているモジュールを優先順位順に配列に格納して返します。
今回はC1クラスを継承したC3クラスのインスタンスに対してancestorsメソッドを呼んでいます。
この場合優先順位としてはC3の方が高くなりますので[C3, C1, Object, Kernel, BasicObject]と表示されます。'

$o_commentary11 = 
  'この問題ではC1クラスを継承したC3クラスに対して.instance_methodsを呼んでいます。instance_methodsの返り値はArray（配列）となりますのでその配列の中にm_1メソッドがあるかをinclude?メソッドで判断しています。
m_1メソッドが定義されているC1クラスをC3クラスが継承しているのでこの場合では「true」と表示されます。'

$o_commentary12 =
  'この問題ではC1クラスのインスタンスであるc1にはm_1メソッドは定義されていません。
よってここでは[]と表示されます。
C1クラスのインスタンスメソッドとしてm_1が定義されています。'

$o_commentary13 =
  'instance_methodsメソッドはあるクラスのインスタンスメソッドの一覧を配列で得ることができるメソッドです。またfalseをつけることでそのモジュールで定義されたインスタンスメソッドのみを返します。
またここで使用されているaliasは別名をつけるための構文です。
よってここではC1クラスで定義されているm_1メソッドをC1クラスを継承したC2クラスで"m_2"という別名をつけています。
よって[:m_2]と表示されます。
元々定義されているm_1メソッドが使用出来なくなることはないこと、alias式には文字列は指定できない事、カンマは不要であるという認識が必要です。'

$o_commentary14 =
  'initializeメソッドは定義されたクラスの初期化メソッドです。
サブクラス(ここではC2)でinitializeメソッドを定義しなかった場合、initializeメソッドも継承されます。
またinstance_variablesメソッドはそのオブジェクトのインスタンス変数名のシンボルを配列で返すメソッドです。
つまりC1クラスを継承したC2クラスでもC1で保持しているインスタンス変数も継承されるので[:@foo, :@bar]と表示されます。
'

$o_commentary15 =
  'undef式は指定した定義を取り消します。
ここではC2クラスにおいてのm_3メソッドの定義が取り消しされています。
C1クラスに定義されているm_3メソッドを取り消しているわけではない事に注意して下さい。
instance_methodsメソッドはあるクラスのインスタンスメソッドの一覧を配列で得ることができるメソッドです。またfalseをつけることでそのモジュールで定義されたインスタンスメソッドのみを返します。
よってここでは[:m_3, :m_1]と表示されます。'

$o_commentary16 =
  'undef式は指定した定義を取り消します。
ここではC2クラスにおいてのm_3メソッドの定義が取り消しされています。
取り消しされたにも関わらず、C2クラスのインスタンスであるc2をレシーバとしてm_3メソッドを呼んでいるのでここでは例外が発生します。
またC1クラスのインスタンスをレシーバとしてm_3メソッドを呼べば例外は発生しません。'

$o_commentary17 =
  'モジュールはメソッドを定義することは出来ますが、インスタンスは生成することは出来ない為、例外が発生します。
  さらに補足するとModule.instance_methods.include?(:new)とするとfalseが返ってきます。Moduleクラスのインスタンスメソッドにnewが定義されていない為、例外が発生します。'
  
$o_commentary18 =
  'ancestorsメソッドはクラス、モジュールのスーパークラスとインクルードしているモジュールを優先順位順に配列に格納して返します。
今回はModuleクラスのM1に対してancestorsメソッドを呼んでいますので[M1]と表示されます。'

$o_commentary19 =
  'includeメソッドはモジュールのメソッドをクラスに取り込む為のメソッドになります。
ここではモジュールM1をクラスC1に取り込んでいます。
ancestorsメソッドはクラス、モジュールのスーパークラスとインクルードしているモジュールを優先順位順に配列に格納して返します。
includeメソッドを使用した際のここでのM1の優先順位は呼び出したクラスの後になります。
よってここでは[C1, M1, Object, Kernel, BasicObject]と表示されます。'

$o_commentary20 =
  'prependメソッドはモジュールのメソッドをクラスに取り込む為のメソッドになります。
  ここではモジュールM1をクラスC1に取り込んでいます。
  ancestorsメソッドはクラス、モジュールのスーパークラスとインクルードしているモジュールを優先順位順に配列に格納して返します。
  prependメソッドを使用した際のここでのM1の優先順位は呼び出したクラスよりも先になります。
  よってここでは[M1, C1, Object, Kernel, BasicObject]と表示されます。'
  
$o_commentary21 =
  'ここでの問題はC1クラスが呼び出しているm_1メソッドはどのm_1メソッドが優先されるのかという問題です。
ここではモジュールM1とM2をクラスC1でインクルードしています。includeメソッドによって取り込まれたモジュールの優先順位はそのクラスよりも後になります。
よってC1で定義されているm_1メソッドが最優先される為、"C1 m_1"と表示されます。
またクラスC1に対してancestorsメソッドを呼ぶと[C1, M2, M1, Object, Kernel, BasicObject]と表示されことからもC1の優先順位が最も高いことが分かります。'

$o_commentary22 =
  'ここでの問題はC1クラスが呼び出しているm_1メソッドはどのm_1メソッドが優先されるのかという問題です。
ここではモジュールM1とM2をクラスC1でインクルードしています。prependメソッドによって取り込まれたモジュールの優先順位はそのクラスよりも先になります。
さらに後にprependメソッドで呼ばれたモジュールが優先される為、ここでは"M2 m_1"と表示されます。
またクラスC1に対してancestorsメソッドを呼ぶと[M2, M1, C1, Object, Kernel, BasicObject]と表示されことからもM2の優先順位が最も高いことが分かります。'

$o_commentary23 =
  'ここではクラスC1のインスタンスであるc1に対してm_2という特異メソッドを定義しています。
よってc1をレシーバとしてm_2メソッドを呼び出すと"m_2"と表示されます。
またc1に対してしかm_2メソッドを定義していないのでc2に対してm_2メソッドを呼び出しても例外が発生することに注意が必要です。'

$o_commentary24 = 
  'ここではクラスC1のインスタンスであるc1に対してm_2という特異メソッドを定義しています。
c1に対してしかm_2メソッドを定義していないことに注意が必要です。
よってc2に対してm_2メソッドを呼び出すと例外が発生します。'

$o_commentary25 =
  'この問題ではクラスC1のインスタンスとしてc1が生成されています。
そのc1に対して特異メソッドであるm_2メソッドが定義されています。
singleton_classメソッドはそのインスタンスの特異クラスを返してくれます。
superclassメソッドはそのクラスの親クラスを返してくれます。
この場合c1の特異クラスの親クラスはC1となりますので「C1」と表示されます。'

$o_commentary26 =
'class_variable_getメソッドはクラスもしくはモジュールに定義されているクラス変数を返してくれます。
initializeメソッドは定義されたクラスの初期化メソッドです。
そして今回ではC1とC2とC3クラスに対してnewメソッドを呼んで3回initializeメソッドが呼ばれています。
サブクラス(ここではC2)でinitializeメソッドを定義しなかった場合、initializeメソッドも継承されます。
よってクラス変数@@countには最終的には3が代入されていますので「3」と表示されます。'

$o_commentary27 =
  'class_variable_getメソッドはクラスもしくはモジュールに定義されているクラス変数を返してくれます。
initializeメソッドは定義されたクラスの初期化メソッドです。
そして今回ではC1とC2とC3クラスに対してnewメソッドを呼んで3回initializeメソッドが呼ばれています。
しかしC3クラスでは新たにinitializeメソッドが定義されており、そこではクラス変数@@countには影響を与えませんよって、@@count += 1 が実行されるのは2回です。
よってここでは「2」と表示されます。'

$o_commentary28 =
  'class_variable_getメソッドはクラスもしくはモジュールに定義されているクラス変数を返してくれます。
initializeメソッドは定義されたクラスの初期化メソッドです。
そして今回ではC1とC2とC3クラスに対してnewメソッドを呼んで3回initializeメソッドが呼ばれています。
しかしC2クラス及び、C3クラスでは新たにinitializeメソッドが定義されており、そこではクラス変数@@countには影響を与えません。
その為、@@count += 1 が実行されるのは1回です。
よってここでは「1」と表示されます。'

$o_commentary29 =
  'class_variable_getメソッドはクラスもしくはモジュールに定義されているクラス変数を返してくれます。
initializeメソッドは定義されたクラスの初期化メソッドです。
そして今回ではC1とC2とC3クラスに対してnewメソッドを呼んで3回initializeメソッドが呼ばれています。
しかしC3クラスでは新たにinitializeメソッドが定義されており、そこではクラス変数@@countには影響を与えません。
またC2クラスでは新たにinitializeメソッドが定義されており、superを呼び出しています。
superは継承チェーン上から同名のメソッドを呼び出しています。
よってC2のinitializeメソッドはC1のそれと同等です。
その為、@@count += 1 が実行されるのは2回です。
よってここでは「2」と表示されます。'

$o_commentary30 =
  'prependメソッドはモジュールのメソッドをクラスに取り込む為のメソッドになります。
ここではモジュールM1をクラスC2に取り込んでいます。
prependメソッドを使用した際のM1の優先順位は呼び出したクラスよりも先になります。
ここではC2クラスのインスタンスであるc2をレシーバとしてm_1メソッドを呼び出しています。
継承チェーンを確認するとM1モジュールのm_1が呼び出されますがその中でさらにsuperが呼ばれています。継承チェーン上でM1よりも優先されるクラスもしくはモジュールはC2となります。
よって
"C2"
"M1"
と表示されます。
'

$o_commentary31 =
  'includeメソッドはモジュールのメソッドをクラスに取り込む為のメソッドになります。
ここではモジュールM1をクラスC2に取り込んでいます。
C2クラスのインスタンスc2をレシーバとしてm_1メソッドをよんでいますが、継承チェーンを確認すると１番優先順位が高いのはC2なのでC2のm_1メソッドが実行されまますがその中でさらにsuperが呼ばれているのでM1モジュールのm_1メソッドが呼ばれます。
そしてさらにその中でsuperが呼ばれているのでC1クラスのm_1メソッドが呼ばれます。

つまりC1→M1→C2の順で実行されますので
"C1"
"M1"
"C2"
と表示されます。
'

$o_commentary32 =
  'C1クラスを継承したC2クラスはM1モジュールをincludeしています。
includeメソッドはモジュールのメソッドをクラスに取り込む為のメソッドになります。
そしてそのインスタンスメソッドをその取り込んだクラスで使用出来る様になります。
methodsメソッドはそのオブジェクトに対して呼び出せるメソッドの一覧を返してくれます。

この問題ではC2オブジェクトがm_1メソッドを呼び出せるのではなくあくまでC2オブジェクトのインスタンスがm_1メソッドを呼び出すことが出来ますので「false」と表示されます。'

$o_commentary33 =
  'C1クラスを継承したC2クラスはM1モジュールをincludeしています。
includeメソッドはモジュールのメソッドをクラスに取り込む為のメソッドになります。
そしてそのインスタンスメソッドをその取り込んだクラスで使用出来る様になります。
instance_methodsメソッドはそのオブジェクトに対して呼び出せるインスタンスメソッドの一覧を返してくれます。

この問題ではC2オブジェクトがC2オブジェクトのインスタンスはm_1メソッドを呼び出すことが出来ますので「true」と表示されます。'

$o_commentary34 =
  'refineメソッドは指定したクラスもしくはモジュールにだけブロックで指定した機能を提供出来るメソッドです。
ここではC2クラスに対してm_2メソッドを提供している事が分かります。
しかしrefineで提供したメソッドはusingメソッドを呼んだ場合のみになります。
よってここではm_2メソッドは呼ぶことは出来ない為、例外が発生します。
またm_2メソッドを呼ぶ前に using M1 とすると呼ぶことが出来る様になります。'

$o_commentary35 =
  'refineメソッドは指定したクラスもしくはモジュールにだけブロックで指定した機能を提供出来るメソッドです。
ここではC2クラスに対してm_2メソッドを提供している事が分かります。
refineで提供したメソッドはusingメソッドを呼んだ場合のみになります。
よってここではm_2メソッドを呼ぶことが出来る為、"M1"と表示されます。'

$o_commentary36 =
  'privateメソッドの定義はシンボルで指定することが可能です。
private_methodsメソッドはそのオブジェクトのprivateメソッドの一覧を返します。
そしてこの問題ではm_1メソッドがprivateメソッドとして定義されているかをinclude?メソッドで判定しています。
よってここでは「true」と表示されます。'

$o_commentary37 =
  'initializeメソッドは定義されたクラスの初期化メソッドです。
そしてinitializeメソッドは自動的にprivateメソッドとして定義されます。
またprivate_methodsメソッドはそのオブジェクトのprivateメソッドの一覧を返します。
その一覧の中にinitializeメソッドが存在するかをinclude?メソッドで判定します。
よってここでは「true」と表示されます。'

$o_commentary38 =
  'method_missingメソッドは呼び出されたメソッドが定義されていなかった時に呼ばれるメソッドです。
この問題では定義していないメソッドであるtest_methodを呼び出しています。
本来であれば例外が発生するところですが、ここではmethod_missingメソッドをオーバーライドしています。
missing_methodの引数であるidにはtest_methodが、*argにはその引数が配列で格納されます。
ここではidを変数展開で出力するメソッドにオーバーライドされているので"test_method"と表示されます。'

$o_commentary39 =
'この問題ではC1クラスでm_1メソッドを定義してさらにalias式でm_1メソッドのエイリアスとしてm_2という名前を指定しています。
さらにC1クラスを再オープンして新たにm_1メソッドを定義しています。
m_2メソッドを呼んだ際に再オープン前後どちらがのm_1が呼ばれるのかはalias式で別名をつけた時点において評価されます。
よってここでは"C1"と表示されます。'

$o_commentary40 =
  'この問題ではC1クラスでm_1メソッドを定義してさらにalias式でm_1メソッドのエイリアスとしてm_2という名前を指定しています。
さらにC1クラスを再オープンして新たにm_1メソッドを定義しておりその中でalias式でm_2メソッドのエイリアスとしてm_3メソッドを定義しています。
m_3メソッドを呼んだ際ですがこの場合はm_2をエイリアスで定義して再オープン前のC1クラスのm_1メソッドが評価されます。
よってここでは"C1"と表示されます。'

$o_commentary41 =
  'この問題ではC1クラスでm_1メソッドを定義してさらにalias式でm_1メソッドのエイリアスとしてm_2という名前を指定しています。
さらにC1クラスを再オープンして新たにm_1メソッドを定義しておりその中でalias式でm_2メソッドのエイリアスとしてm_3メソッドを定義しています。
しかしここではalias式に文字列が指定されていますが文字列は指定することが出来ません。
よってここでは例外が発生します。'

$o_commentary42 =
  'この問題ではC1クラスでm_1メソッドを定義してさらにalias_methodメソッドでm_1のエイリアスとしてm_2という名前で定義しています。
alias_methodメソッドはメソッドの別名を定義するメソッドです。引数には文字列もしくはシンボルでメソッド名を渡すことが可能です。

さらにC1クラスを再オープンして新たにm_1メソッドを定義しておりその中でalias式でm_2メソッドのエイリアスとしてm_3メソッドを定義しています。
m_3メソッドを呼んだ際ですがこの場合はm_2をエイリアスで定義して再オープン前のC1クラスのm_1メソッドが評価されます。
よってここでは"C1"と表示されます。'

$o_commentary43 =
  'initializeメソッドは定義されたクラスの初期化メソッドです。
initializeメソッドで初期化された際に"foo"が@objにそのまま代入されています。
C1クラスのインスタンスに対してm_1メソッドを呼んでいる為、"foo"と表示されます。'

$o_commentary44 =
  'superは現在のメソッドがオーバーライドしているメソッドを呼び出します。
C1クラスを継承したC2クラスのインスタンスをレシーバとして引数ありでm_1メソッドを呼び出しています。
ですが引数を渡さずにオーバーライドしたメソッドを呼び出すにはsuper()として明示的に引数がない事を示さなくては例外が発生します。
よってここでは例外が発生します。
'

$o_commentary45 =
  'superは現在のメソッドがオーバーライドしているメソッドを呼び出します。
C1クラスを継承したC2クラスのインスタンスをレシーバとして引数ありでm_1メソッドを呼び出しています。
ですが引数を渡さずにオーバーライドしたメソッドを呼び出すにはsuper()として明示的に引数がない事を示さなくては例外が発生します。
ここではsuper()と引数がない事を明示しているので
"m_1"
"m_2"
と表示されます。
'

$o_commentary46 =
  'superは現在のメソッドがオーバーライドしているメソッドを呼び出します。
C1クラスを継承したC2クラスのインスタンスをレシーバとして引数ありでm_1メソッドを呼び出しています。
よってここでは
"m_1"
"m_2"
と表示されます。'

$o_commentary47 =
  'nestingメソッドはこのメソッドを呼び出した時点でのクラスもしくはモジュールのネスト情報を配列にして返します。
この問題ではM1モジュールの中のM3モジュールでこのメソッドを呼び出しています。
よってここでは[M1::M3, M1]と表示されます。
'

$o_commentary48 =
  'nestingメソッドはこのメソッドを呼び出した時点でのクラスもしくはモジュールのネスト情報を配列にして返します。
この問題ではM1モジュールの中でこのメソッドを呼び出しています。
よってここでは[M1]と表示されます。
'

$o_commentary49 =
  'nestingメソッドはこのメソッドを呼び出した時点でのクラスもしくはモジュールのネスト情報を配列にして返します。
この問題ではM1モジュールの中のM2モジュールの中のM3モジュールの中でこのメソッドを呼び出しています。
よってここでは[M1::M2::M3, M1::M2, M1]と表示されます。'

$o_commentary50 =
  'nestingメソッドはこのメソッドを呼び出した時点でのクラスもしくはモジュールのネスト情報を配列にして返します。
この問題ではM1モジュールの中のM2モジュールの中でこのメソッドを呼び出しています。
よってここでは[M1::M2, M1]と表示されます。'

$o_commentary51 =
  'モジュールはメソッドを定義することは出来ますが、インスタンスは生成することは出来ない為、例外が発生します。
さらに補足するとModule.instance_methods.include?(:new)とするとfalseが返ってきます。Moduleクラスのインスタンスメソッドにnewが定義されていない為、例外が発生します。'

$o_commentary52 =
  'module_functionメソッドは引数で渡したメソッドをモジュール関数として呼べるようになるメソッドです。
この方法で定義されたメソッドはそのモジュールの特異メソッドであると同時にprivateメソッドとして定義されます。
よってここでは"m_1"と表示されます。
'

$o_commentary53 =
  'freezeメソッドはそのオブジェクトを凍結(内容の変更を禁止する)させます。
ここでは[1,2,3,4,5]という配列オブジェクトをfreezeメソッドによって凍結しているにも関わらず内容の変更を試みている為、例外が発生します。
また配列の要素はfreezeされていない点に注意が必要です。'

$o_commentary54 =
'freezeメソッドはそのオブジェクトを凍結(内容の変更を禁止する)させます。
ここでは[1,2,3,4,5]という配列オブジェクトをfreezeしていますが定数に代入される要素自体を変更する事は可能です。
ここでは警告が発生した後[1,3,3,4,5]と表示されます。'

$o_commentary55 =
  'freezeメソッドはそのオブジェクトを凍結(内容の変更を禁止する)させます。
ここでは[1, 2]という配列オブジェクトをfreezeして変数obj1に代入しています。
dupメソッドはそのオブジェクトの内容をコピーしますが凍結状態はコピーしません。
よって例外を出すことなく内容の変更が可能なので[5, 2]と表示されます。
'

$o_commentary56 =
  'freezeメソッドはそのオブジェクトを凍結(内容の変更を禁止する)させます。
ここでは[1, 2]という配列オブジェクトをfreezeして変数obj1に代入しています。
cloneメソッドはそのオブジェクトの内容や凍結状態までコピーします。
ここでは凍結しているにも関わらず内容の変更をしようとしている為、例外が発生します。'

$o_commentary57 =
  'C1クラスの中とその外側は別のスコープです。
つまり外側で定義したobj1はC1クラス内部では使うことは出来ません。
ここではm_1メソッドの中でobj1を参照しようとしますが変数が見つからない為、例外が発生します。'

$o_commentary58 =
  'constantsメソッドはそのクラスやモジュールで定義されている定数を配列にして返してくれます。
ここではM1モジュール中のC1クラスの定数が評価されるので[:A]と表示されます。'

$o_commentary59 =
  'constantsメソッドはそのクラスやモジュールで定義されている定数を配列にして返してくれます。
ここではM1モジュール中の定数が配列で帰りますので[:C1, :C2, :D]と表示されます。
クラス名も定数であるという認識が必要になります。
また定数Aを参照したければ M1::C1.constants とすると参照できます。'

$o_commentary60 =
  'constantsメソッドはそのクラスやモジュールで定義されている定数を配列にして返してくれます。
  C2.constants としていますがこの問題ではM1::C2という定数は存在しますがC2という定数は存在しない為、例外が発生します。'